---
layout: post
title: 话题通信
date: 2023-08-01 10:00:00
description: 话题通信
tags: ROS
categories: ROS
---

# 话题通信

#### 话题通信c++基本实现流程（配置略）：

逻辑：

```纯文本
发布方逻辑：
  1.包含头文件
  2.初始化 ROS 节点:命名(唯一)
  3.实例化 ROS 句柄
  4.实例化 发布者 对象
  5.组织被发布的数据，并编写逻辑发布数据
订阅方逻辑：
  1.包含头文件 
  2.初始化 ROS 节点:命名(唯一)
  3.实例化 ROS 句柄
  4.实例化 订阅者 对象
  5.处理订阅的消息(回调函数)
  6.设置循环调用回调函数
```

代码示例：

```纯文本
发布方：
  #include "ros/ros.h"
  #include "std_msgs/String.h"
  #include <sstream>
  
  int a=1,b=1;
  
  int feibo(int x)
  {
      int tmp=b;
      if(x==1||x==2)
      return 1;
      else
      {
          b+=a;
          a=tmp;
          return b;
      }
  }
  
  int main(int argc,char *argv[])
  {
      setlocale(LC_ALL,"");
  
      ros::init(argc,argv,"fabuzhe");
      ros::NodeHandle nh;
      ros::Publisher pub=nh.advertise<std_msgs::String>("fibonacci",10);
      std_msgs::String msg;
      ros::Rate rate(10);
      int count=0;
      ros::Duration(1).sleep();// 留时间来在master中注册
      while(ros::ok())
      {
          count++;
          std::stringstream ss;
          ss<<feibo(count);
  
          msg.data=ss.str();
  
          pub.publish(msg);
          
          ROS_INFO("发布的数据是%s",ss.str().c_str());
          rate.sleep();
          ros::spinOnce();//官方建议的处理回调函数
      }
      return 0;
  }
  
--------------------------------------------------------------------------
订阅方：
  #include "ros/ros.h"
  #include "std_msgs/String.h"
  
  void doMSG(const std_msgs::String::ConstPtr &msg)
  {
      ROS_INFO("%s ",msg->data.c_str());
  }
  
  int main(int argc,char *argv[])
  {
      setlocale(LC_ALL,"");
  
      ros::init(argc,argv,"jieshouzhe");
      ros::NodeHandle nh;
      ros::Subscriber sub=nh.subscribe<std_msgs::String>("fibonacci",10,doMSG);
  
      ros::spin();
      return 0;
  }

```

#### 话题通信python实现流程（配置略）：

逻辑：

```纯文本
 发布者逻辑：
  1.导包 
  2.初始化 ROS 节点:命名(唯一)
  3.实例化 发布者 对象
  4.组织被发布的数据，并编写逻辑发布数据
 订阅者逻辑：
  1.导包 
  2.初始化 ROS 节点:命名(唯一)
  3.实例化 订阅者 对象
  4.处理订阅的消息(回调函数)
  5.设置循环调用回调函数
```

代码示例：

```纯文本
发布者：
  #! /usr/bin/env python
  #上方为shebang行用于指定默认的python解释器
  import rospy
  from std_msgs.msg import String
  
  a=1
  b=1
  
  def js(x):
      global a,b
      if(x==1 or x==2):
          return 1
      else:
          tmp=b
          b+=a
          a=tmp
          return b
  
  if __name__ == "__main__":
      rospy.init_node("tolker")
      pub=rospy.Publisher("fibonacci",String,queue_size=10)
  
      msg=String()
      rate=rospy.Rate(1)
      count=0
  
      rospy.sleep(1)
      while not rospy.is_shutdown():
          count+=1
          ans=js(count)
          msg.data=str(ans)
          pub.publish(msg)
          rospy.loginfo("输出的数据为:%s",msg.data)
          rate.sleep()
 
订阅者：
  #! /usr/bin/env python
  import rospy
  from std_msgs.msg import String
  
  def doMSG(msg):
      rospy.loginfo("%s ",msg.data)
  
  if __name__ == "__main__":
      rospy.init_node("listener")
      sub=rospy.Subscriber("fibonacci",String,doMSG,queue_size=10)
      rospy.spin()

```

#### 自定义消息类型略
