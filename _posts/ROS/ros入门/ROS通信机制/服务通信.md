---
layout: post
title: 服务通信
date: 2023-08-01 10:00:00
description: 服务通信
tags: ROS
categories: ROS
---

# 服务通信

## 一、自定义srv

**流程:**

srv 文件内的可用数据类型与 msg 文件一致，且定义 srv 实现流程与自定义 msg 实现流程类似:

1.  按照固定格式创建srv文件
2.  编辑配置文件
3.  编译生成中间文件

## 三、自定义srv调用(python)

**流程:**

1.  编写服务端实现；
2.  编写客户端实现；
3.  编辑配置文件；
4.  编译并执行。

#### 0.vscode配置

需要像之前自定义 msg 实现一样配置c\_cpp\_properies.json 文件，如果以前已经配置且没有变更工作空间，可以忽略，如果需要配置，配置方式与之前相同:

```纯文本
{

  "configurations": [

    {

      "browse": {

        "databaseFilename": "",

        "limitSymbolsToIncludedHeaders": true

      },

      "includePath": [

        "/opt/ros/noetic/include/**",

        "/usr/include/**",

        "/xxx/yyy工作空间/devel/include/**" //配置 head 文件的路径 

      ],

      "name": "ROS",

      "intelliSenseMode": "gcc-x64",

      "compilerPath": "/usr/bin/gcc",

      "cStandard": "c11",

      "cppStandard": "c++17"

    }

  ],

  "version": 4

}
```

#### 1.服务端

```纯文本
/*
逻辑：
    1.包含头文件
    2.初始化 ROS 节点
    3.创建 ROS 句柄
    4.创建 服务 对象
    5.回调函数处理请求并产生响应
    6.由于请求有多个，需要调用 ros::spin()
*/

#include "ros/ros.h"
#include "plubing_server_client/addint.h"

bool doADD(plubing_server_client::addint::Request &req,plubing_server_client::addint::Response &res)
{
    int num1=req.num1;
    int num2=req.num2;
    ROS_INFO("收到数据：%d,%d",num1,num2);
    int sum=num1+num2;
    res.sum=sum;
    ROS_INFO("求得的数据：%d",sum);
    return true;
}

int main(int argc,char *argv[])
{
    setlocale(LC_ALL,"");
    ros::init(argc,argv,"server");
    ros::NodeHandle nh;
    ROS_INFO("服务已经启动------");
    ros::ServiceServer server=nh.advertiseService("addint",doADD);
    
    ros::spin();
    return 0;
}

```

#### 2.客户端

```纯文本
/*
逻辑：
    1.包含头文件
    2.初始化 ROS 节点
    3.创建 ROS 句柄
    4.创建 客户端 对象
    5.请求服务，接收响应
*/

#include "ros/ros.h"
#include "plubing_server_client/addint.h"

int main(int argc,char *argv[])
{
    setlocale(LC_ALL,"");
    if(argc!=3)
    {
        ROS_INFO("提交的参数个数错误");
    }
    else
    {
        ros::init(argc,argv,"client");
        ros::NodeHandle nh;
        ros::ServiceClient client=nh.serviceClient<plubing_server_client::addint>("addint");
        plubing_server_client::addint ai;
        ai.request.num1=atoi(argv[1]);
        ai.request.num2=atoi(argv[2]);
        client.waitForExistence();//判断服务端是否启动，从而决定是否挂起
        bool flag=client.call(ai);
        if(flag)
        {
            ROS_INFO("响应成功");
            ROS_INFO("响应结果为：%d",ai.response.sum);
        }
        else
        {
            ROS_INFO("响应失败");
        }
    }
    
    return 0;
}

```

#### 3.配置 CMakeLists.txt

```纯文本
add_executable(AddInts_Server src/AddInts_Server.cpp)

add_executable(AddInts_Client src/AddInts_Client.cpp)

add_dependencies(AddInts_Server ${PROJECT_NAME}_gencpp)

add_dependencies(AddInts_Client ${PROJECT_NAME}_gencpp)

target_link_libraries(AddInts_Server

  ${catkin_LIBRARIES}

)

target_link_libraries(AddInts_Client

  ${catkin_LIBRARIES}

)
```

#### 4.执行

**流程:**

-   需要先启动服务:`rosrun 包名 服务`
-   然后再调用客户端 :`rosrun 包名 客户端 参数1 参数2`

**结果:**

会根据提交的数据响应相加后的结果。

**注意:**

如果先启动客户端，那么会导致运行失败

**优化:**

在客户端发送请求前添加:`client.waitForExistence();`

或:`ros::service::waitForService("AddInts");`

这是一个阻塞式函数，只有服务启动成功后才会继续执行

此处可以使用 launch 文件优化，但是需要注意 args 传参特点

## 三、自定义srv调用(python)

**流程:**

1.  编写服务端实现；
2.  编写客户端实现；
3.  为python文件添加可执行权限；
4.  编辑配置文件；
5.  编译并执行。

#### 0.vscode配置

需要像之前自定义 msg 实现一样配置settings.json 文件，如果以前已经配置且没有变更工作空间，可以忽略，如果需要配置，配置方式与之前相同:

```c++
{

  "python.autoComplete.extraPaths": [

    "/opt/ros/noetic/lib/python3/dist-packages",

  ]
}
```

#### 1.服务端

```python
#! /usr/bin/env python
"""
逻辑：
    1.导包
    2.初始化 ROS 节点
    3.创建服务对象
    4.回调函数处理请求并产生响应
    5.spin 函数
"""

import rospy
from plubing_server_client.srv import addint,addintRequest,addintResponse

def doreq(req):
    sum=req.num1+req.num2
    response=addintResponse()
    response.sum=sum
    rospy.loginfo("服务器响应:%d+%d=%d",req.num1,req.num2,response.sum)
    return response

if __name__ =="__main__":
    rospy.init_node("pyserver")
    server=rospy.Service("addint",addint,doreq)
    rospy.loginfo("服务已启动--------")
    rospy.spin()

```

#### 2.客户端

```python
 #! /usr/bin/env python
"""
逻辑：
    1.导包
    2.初始化 ROS 节点
    3.创建请求对象
    4.发送请求
    5.接收并处理响应
  优化:
    加入数据的动态获取
  """
import rospy
from plubing_server_client.srv import *
import sys

if __name__ == "__main__":
    if len(sys.argv)!=3:
        rospy.logerr("请正确提交参数")
        sys.exit(1)
    
    rospy.init_node("pyclient")
    client=rospy.ServiceProxy("addint",addint)
    client.wait_for_service()
    req=addintRequest()
    req.num1=int(sys.argv[1])
    req.num2=int(sys.argv[2])
    response=client.call(req.num1,req.num2)
    rospy.loginfo("收到回复:%d",response.sum)
```

#### 3.设置权限

终端下进入 scripts 执行:`chmod +x *.py`

#### 4.配置 CMakeLists.txt

**CMakeLists.txt**

```text
catkin_install_python(PROGRAMS

  scripts/AddInts_Server_p.py 

  scripts/AddInts_Client_p.py

  DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}

)
```

#### 5.执行

**流程:**

-   需要先启动服务:`rosrun 包名 服务`
-   然后再调用客户端 :`rosrun 包名 客户端 参数1 参数2`

**结果:**

会根据提交的数据响应相加后的结
